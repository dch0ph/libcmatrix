/*! \file
  \brief Functionality for direct addition of lineshapes to frequency histograms

*/

#undef LCM_SUPPRESS_VIEWS
#include "Lineshapes.h"
#include <cmath>

namespace libcmatrix {

  int verbose_interpolate=0;

  BaseLineshape::hash_t BaseLineshape::hash(double off, int binkey) const
  {
    if (binkey<0) 
      return -hash(off,-binkey);
    else
      return int(0.5+spec_.resolution_steps*(binkey+off));
  }

  void BaseLineshape::reversehash(double& offset, int& binkey, hash_t hash) const
  {
    if (hash<0) {
      reversehash(offset,binkey,-hash);
      binkey=-binkey;
    }
    else {
      binkey=hash/int(spec_.resolution_steps);
      offset=double(hash-spec_.resolution_steps*binkey)/spec_.resolution_steps;
    }
  }

  const double LorentzianGaussian::PureLorentzian=0.0;
  const double LorentzianGaussian::PureGaussian=1.0;

  void LorentzianGaussian::cache_t::reset()
  {
    gauss.create(0U);
    lorentz.create(0U);
  }

 void LorentzianGaussian::cache_t::make(const LorentzianGaussian& obj, hash_t key)
 {
   reset(); //!< invalidate cached values
   ensure(obj,key);
 }

  void LorentzianGaussian::cache_t::swap(cache_t& a)
  {
    gauss.swap(a.gauss);
    lorentz.swap(a.lorentz);
  }
  
  double LorentzianGaussian::lorentzval(double f) const {
    return ls_/(a2_+f*f); 
  }

  double LorentzianGaussian::gaussval(double f) const {
    return gs_*std::exp(-ga_*f*f); 
  }

void LineshapeSpec::validate() const
{
  if ((cutoff<0.0) || (cutoff>=1.0))
    throw InvalidParameter("LineshapeSpec: cutoff must be between 0 and 1");
}

  BaseLineshape::BaseLineshape(const LineshapeSpec& spec)
    : spec_(spec)
{
  spec.validate(); //!< need to verify here since LineshapeSpec is a simple struct
  reset_counts();
}

  void LorentzianGaussian::cache_t::ensure(const LorentzianGaussian& obj, hash_t key)
  {
    double offset;
    size_t bin;
    obj.getbin(bin,offset,key);
    if ((obj.frac_!=PureLorentzian) && gauss.empty())
      obj.makeg_(gauss,bin,offset);
    if ((obj.frac_!=PureGaussian) && lorentz.empty())
      obj.makel_(lorentz,bin,offset);
  }

void LorentzianGaussian::getbin(size_t& umid, double& offset, hash_t key) const
{
  int mid;
  reversehash(offset,mid,key);
  mid+=getmid();
  const size_t nbins=speccache_.nbins;
  assert((mid>=0) && (mid<nbins));
  umid=mid;
  offset*=speccache_.rangef/nbins;
}

  void LorentzianGaussian::cache_t::operator()(List<double>& dest, double frac) const
  {
    if (frac==PureGaussian)
      dest=gauss;
    else {
      dest=lorentz;
      if (frac!=PureLorentzian) {
	dest*=frac;
	mla(dest,1.0-frac,gauss);
      }
    }
  }

#define CALL_MEMBER_FN(obj,fptr) ((obj).*(fptr))

  size_t LorentzianGaussian::make_(List<double>& dest,size_t mid, double offset, const char* name, LineshapeFunc_t func,double zeroval) const
  {
    const double cut=zeroval*spec_.cutoff;
    const size_t nbins=speccache_.nbins;
    const double deltaf=speccache_.rangef/nbins;
    dest.create(nbins);
    if (name && (spec_.flags & LineshapeSpec::verbose))
      std::cout << "Creating " << name << " with width " << lw_ << " centered on bin " << mid << " with frequency offset " << offset << '\n';

    if (spec_.cutoff)
      dest=0.0; //!< only zero if no cutoff
    int width=0;

    if (offset==0.0) {//!< symmetrical
      dest(size_t(mid))=zeroval;
      for (width=1;;width++) {
	offset+=deltaf;
	const double v=CALL_MEMBER_FN(*this,func)(offset);
	if (v<cut)
	  break;
	const size_t upperbin=mid+width;
	bool failed=true;
	if (upperbin<nbins) {
	  dest(upperbin)=v;
	  failed=false;
	}
	const int lowerbin=mid-width;
	if (lowerbin>=0) {
	  dest(size_t(lowerbin))=v;
	  failed=false;
	}
	if (failed) //!< break out if finished
	  break; 
      }
    }
    else { //!< asymmetrical
      double loffset=-offset;
      double roffset=deltaf-offset;
      for (width=0;;width++) {       //! could be a bit smarter and not calculate one side when out of range, but this wouldn't gain much
	const double lv=CALL_MEMBER_FN(*this,func)(loffset);
	const double rv=CALL_MEMBER_FN(*this,func)(roffset);
	if ((lv<cut) && (rv<cut))
	  break;
	const size_t upperbin=mid+1+width;
	bool failed=true;
	if (upperbin<nbins) {
	  dest(upperbin)=rv;
	  failed=false;
	}
	const int lowerbin=mid-width;
	if (lowerbin>=0) {
	  dest(size_t(lowerbin))=lv;
	  failed=false;
	}
	if (failed) //!< break out if finished
	  break; 
	loffset-=deltaf;
	roffset+=deltaf;
      }
    }
    return width;
  }

  void LorentzianGaussian::makel_(List<double>& dest, size_t mid, double offset) const
  {
    const size_t width=make_(dest,mid,offset,"Lorentzian",&LorentzianGaussian::lorentzval,lorentz0());
    if (width>Lwidth_)
      Lwidth_=width;
  }

  void LorentzianGaussian::makeg_(List<double>& dest, size_t mid, double offset) const
  {
    const size_t width=make_(dest,mid,offset,"Gaussian",&LorentzianGaussian::gaussval,gauss0());
    if (width>Gwidth_)
      Gwidth_=width;
  }

  size_t LorentzianGaussian::gethalfwidth() const
  {
    if (frac_==PureLorentzian)
      return Lwidth_;
    if (frac_==PureGaussian)
      return Gwidth_;
    if ((Lwidth_==0U) || (Gwidth_==0U))
      return 0U;
    return std::max(Lwidth_,Gwidth_);
  }
  
  void LorentzianGaussian::reset()
  {
    BaseLineshape::reset_counts();
    //! clear cache *contents* but not memory itself
    const cachemap_t::iterator end(cachemap_.end());
    cachemap_t::iterator iter(cachemap_.begin());
    while (iter!=end) {
      iter->second.reset();
      ++iter;
    }
    cachet_.create(0U);
    Lwidth_=Gwidth_=0U;
  }
  
  void BaseLineshape::flags(int flagsv)
  { 
    int diff=spec_.flags ^ flagsv;
    static const int trivialmask=LineshapeSpec::verbose;
    if (diff) {
      spec_.flags=flagsv;      
      if (diff & ~trivialmask)
	reset();
    }
  }

void BaseLineshape::reset_counts()
{
  callcount_=hitcount_=0;
}
  
  void LorentzianGaussian::print(std::ostream& ostr) const
  {
    ostr << "Linewidth: " << lw_ << " Hz   G/L fraction: " << (100.0*frac_) << "%\n";
    ostr << "Lorentzian half-width: " << Lwidth_ << " bins   Gaussian half-width: " << Gwidth_ << " bins\n";
    ostr << "Cached lineshapes: " << cachemap_.size() << '\n';
    ostr << "Call count: " << callcount_ << "  Cache usage: " << hitcount_ << " (" << ((100.0*hitcount_)/callcount_) << "%)\n";
  }

  int LorentzianGaussian::operator()(List<double>& dest, const HistogramSpec& histspec, double freq) const
  {
    if (lw_==0.0)
      throw Failed("LorentzianGaussian: lineshape requested before linewidth set");
    //    if (histspec.nbins!=dest.size())
    //  throw Mismatch("LorentzianGaussian::make");

    if (histspec!=speccache_) {
      LorentzianGaussian* nonconst_this=const_cast< LorentzianGaussian*>(this);
      nonconst_this->reset(); //!< clear cache if histogram specification has changed
      speccache_=histspec;
    }
         
    const double ifreq=freq;
    
    const bool nofolding=spec_.flags & LineshapeSpec::nofold;
    const bool isverbose=spec_.flags & LineshapeSpec::verbose;
    const bool allowvar=spec_.flags & LineshapeSpec::variable;
    const size_t nbins=histspec.nbins;
    if (!nofolding)
      freq=mod(freq-histspec.minf,histspec.rangef);
    
    int bin;
    double offset=0.0;
    const double deltaf=histspec.rangef/nbins;
    const double scalef=1.0/deltaf;
	
    if (spec_.resolution_steps<2)
      bin = nofolding ? int(scalef*(freq-histspec.minf)) : int(scalef*freq);
    else {
      if (nofolding) {
	const double relfreq=freq-histspec.minf;
	if (relfreq<0) //!< always round down
	  bin=-int(scalef*-relfreq)-1;
	else
	  bin=int(scalef*relfreq);
	offset=(freq-histspec.minf)/deltaf-bin;
      }
      else {
	bin=int(scalef*freq);
	offset=freq/deltaf-bin;
      }
      //!< catch rounding problems
      if (offset>=1.0) {
	offset-=1.0;
	bin++;
      }
    }
    const int mid=getmid();
    if (isverbose)
      std::cout << "Initial frequency " << ifreq << " reduced to bin " << bin << ", fractional offset " << offset << '\n';
    assert((offset>=0.0) && (offset<=1.0));
    if ((bin<0) || (bin>=nbins)) {
      if (isverbose)
	std::cerr << "Warning: frequency outside histogram range (ignored)\n";
      if (allowvar)
	dest.create(0U);
      else
	dest.create(nbins,0.0);
      return -1;
    }
    int binkey=0;
    int roll=bin-mid;
    int halfwidth=gethalfwidth();
    if (nofolding && ((halfwidth==0U) || (spec_.cutoff==0) || (std::abs(binkey)+halfwidth>=mid))) {
      roll=0;
      binkey=bin-mid;
    }
    
    const hash_t hashkey(hash(offset,binkey));
    if (isverbose) {
      std::cout << "Post-folding binkey " << binkey << ", roll " << roll << '\n';
      std::cout << "Hashed to " << hashkey << '\n';
      double noff;
      int nbin;
      reversehash(noff,nbin,hashkey);
      const double offshift=spec_.resolution_steps*fabs(noff-offset);
      if ((offshift>1.0) || (nbin!=binkey)) {
	std::cerr << "Reverse hash failed: binkey " << nbin << ", offset " << offset << std::endl;
	throw InternalError("LorentzianGaussian");
      }
    }
    callcount_++;
    cachemap_t::iterator iter(cachemap_.find(hashkey));
    cache_t* sourcep=&tmp_;
    if (iter==cachemap_.end()) {
      tmp_.make(*this,hashkey);
      if (cachemap_.size()<spec_.cache_maximum) {
	cache_t& curentry(cachemap_[hashkey]);
	curentry.swap(tmp_);
	sourcep=&curentry;
	if (isverbose)
	  std::cout << "Creating cached lineshape for hash: " << hashkey << '\n';
      }
      else {
	if (isverbose)
	  std::cout << "Cache full\n";
      }
    }
    else {
      sourcep=&(iter->second);
      sourcep->ensure(*this,hashkey);
      if (isverbose)
	std::cout << "Using cached lineshape for hash: " << hashkey << '\n';
      hitcount_++;
    }

    (*sourcep)(cachet_,frac_); //!< create lineshape
    
    halfwidth=gethalfwidth(); //!< re-read as it might have been updated
    if (halfwidth==0)
      throw InternalError("LorentzianGaussian");

    const int origin=mid+roll;
    const int left=origin-halfwidth;
    const int right=origin+halfwidth;
    const bool doesfit=(right<nbins) && (left>=0);
    const BaseList<double> sourceshape(cachet_(range(mid-halfwidth,mid+halfwidth)));

    if (!allowvar || !doesfit) {
      if (roll==0)
	dest=cachet_;
      else {
	dest.create(nbins);
	if (isverbose) 
	  std::cout << "Making lineshape with halfwidth " << halfwidth << " bins and roll factor " << roll << '\n';
	if (doesfit) {//!< shape fits entirely 
	  dest=0.0;
	  BaseList<double> destsub(dest(range(left,right)));
	  destsub=sourceshape;
	}
	else {
	  if (roll<0)
	    roll+=nbins;
	  if ((roll<0) || (roll>=nbins))
	    throw InternalError("LorentzianGaussian(2)");
	  BaseList<double> dest1(dest(range(roll,nbins-1)));
	  dest1=cachet_(range(0U,nbins-roll-1));
	  BaseList<double> dest2(dest(range(0U,roll-1)));
	  dest2=cachet_(range(nbins-roll,nbins-1));
	}
      }
      return 0;
    }
    //variable width
    if (isverbose) 
      std::cout << "Making (restricted) lineshape with halfwidth " << halfwidth << " bins\n";
    dest=sourceshape;
    return left;
  }  
  
  LorentzianGaussian::LorentzianGaussian(double lw, double frac, const LineshapeSpec& specv)
    : BaseLineshape(specv), Lwidth_(0U), Gwidth_(0U)
  {
    setlw_(lw);
    setfraction_(frac);
  }
  
  void LorentzianGaussian::lw(double nlw)
  {
    if (nlw!=lw_) {
      setlw_(nlw);
      reset();
    }
  }
  
  void LorentzianGaussian::fraction(double nfrac)
  {
    if (nfrac!=frac_) {
      setfraction_(nfrac);
      cachet_.create(0U); //!< only invalidate total cache
    }
  }
  
  void LorentzianGaussian::setlw_(double nlw)
  {
    if (nlw<=0.0)
      throw InvalidParameter("LorentzianGaussian: linewidth cannot be <=0.0");
    lw_=nlw;
    a_=lw_/2.0;
    a2_=a_*a_;
    ls_=a_/M_PI;
    static const double ln2=std::log(2.0);
    ga_=ln2/a2_;
    gs_=std::sqrt(ga_/M_PI);    
  }
  
  void LorentzianGaussian::setfraction_(double nfrac)
  {
    if ((nfrac<0.0) || (nfrac>1.0))
      throw InvalidParameter("LorentzianGaussian: L/G fraction must be between 0 and 1");
    frac_=nfrac;
  }

// cubic interpolation from Numerical Recipes via SIMPSON 

/* Given four data points y1,y2,y3,y4 with x-values starting from x1
   and incremented with dx1, return the function value
   at x-value x using a polynomial of third degree as the interpolating
   function. Calculated using Lagrange's classical formula e.g. described in
   Numerical Recipes. */

template<typename T> T pol3int(double x,double x1,double dx,const T y[4])
{   
   const double t1=x-x1;
   const double t2=t1-dx;
   const double t3=t2-dx;
   const double t4=t3-dx;

   const double dx3=dx*dx*dx;
   const double tedge=t2*t3/(6*dx3);
   const double tmid=t1*t4/(2*dx3);

   T r((-t4*tedge)*y[0]);
   mla(r, t3*tmid,y[1]);
   mla(r,-t2*tmid,y[2]);
   mla(r, t1*tedge,y[3]);
  
   if (verbose_interpolate)
     std::cout << "Interpolated (" << x1 << ',' << y[0] << ") (" << (x1+dx) << ',' << y[1] << ") (" << (x1+2*dx) << ',' << y[2] << ") (" << (x1+3*dx) << ',' << y[3] << ") at " << x << " to give " << r << '\n'; 
   return r;   
}

//! interpolate with values outside range clamped to \a padding
template<typename T> void cubic_interpolate_(BaseList<T>& dest, double newstart, double newdx, const BaseList<T>& source, double oldstart, double olddx, T padding =T(0))
{
  const size_t newnp=dest.size();
  const size_t oldnp=source.size();
  if ((oldnp<3) || (newnp<1))
    throw Failed("cubic_interpolate: insufficient data points for interpolation");
  if ((olddx<=0.0) || (newdx<=0.0))
    throw InvalidParameter("cubic_interpolate: frequency step must be >=0");

  //const double olddx=(oldend-oldstart)/oldnp;
  //const double newdx=(newend-newstart)/newnp;
  //  const size_t oldnp2=oldnp-2;
  T y[4];
  for (size_t j=0;j<newnp;j++) {
    const double newf=j*newdx+newstart;
    const int oldi=int((newf-oldstart)/olddx+0.5); //!< nearest old point
    if (verbose_interpolate)
      std::cout << "Interpolating new point " << j << " (" << newf << ") starting from point " << oldi << '\n';
    for (size_t k=4;k--;) {
      int curi=oldi+k-1;
      y[k]=((curi<0) || (curi>=oldnp))
	? padding
	: source(size_t(curi));
    }
    dest(j)=pol3int(newf,oldstart+(oldi-1)*olddx,olddx,y);
//     if (oldi<1) {
//       dest(j)=pol3int(newf,oldstart,olddx,source(0U),source(1U),source(2U),source(3U));
//     }
//     else {
//       if (oldi>=oldnp2)
// 	dest(j)=pol3int(newf,oldstart+(oldnp-4)*olddx,olddx,source(oldnp2-2),source(oldnp2-1),source(oldnp2),source(oldnp2+1));
//       else
// 	dest(j)=pol3int(newf,oldstart+(oldi-1)*olddx,olddx,source(oldi-1),source(oldi),source(oldi+1),source(oldi+2));
//     }   
  }
}

//! interpolate with folding (can't change window)
template<typename T> void cubic_interpolate_(BaseList<T> dest, const BaseList<T>& source)
{
  const size_t newnp=dest.size();
  const size_t oldnp=source.size();
  if ((oldnp<3) || (newnp<1))
    throw Failed("cubic_interpolate: insufficient data points for interpolation");
  const double r=double(oldnp)/newnp;
  T y[4];
  for (size_t j=0;j<newnp;j++) {
    const double oldf=j*r;
    const size_t oldi=int(oldf+0.5); //!< nearest old point
    size_t k=0;
    if (j==0) {
      y[0]=source.back();
      k++;
    }    
    for (;k<4;k++) {
      size_t curi=oldi+k-1;
      if (curi>=oldnp)
	y[k]=source(size_t(curi-int(oldnp)));
      else
	y[k]=source(curi);
    }
    dest(j)=pol3int(oldf,oldi-1.0,1.0,y);
  }
}

void cubic_interpolate(BaseList<double> dest, double newstart, double newdx, const BaseList<double>& source, double oldstart, double olddx, double padding)
{
  cubic_interpolate_(dest,newstart,newdx,source,oldstart,olddx,padding);
}

List<double> cubic_interpolate(size_t newnp, double newstart, double newdx, const BaseList<double>& source, double oldstart, double olddx, double padding)
{
  List<double> dest(newnp);
  cubic_interpolate_(dest,newstart,newdx,source,oldstart,olddx,padding);
  return dest;
}

void cubic_interpolate(BaseList<double> dest, const BaseList<double>& source)
{
  cubic_interpolate_(dest,source);
}

List<double> cubic_interpolate(size_t newnp, const BaseList<double>& source)
{
  List<double> dest(newnp);
  cubic_interpolate_(dest,source);
  return dest;
}

void cubic_interpolate(BaseList<complex> dest, double newstart, double newdx, const BaseList<complex>& source, double oldstart, double olddx, complex padding)
{
  cubic_interpolate_(dest,newstart,newdx,source,oldstart,olddx,padding);
}

List<complex> cubic_interpolate(size_t newnp, double newstart, double newdx, const BaseList<complex>& source, double oldstart, double olddx, complex padding)
{
  List<complex> dest(newnp);
  cubic_interpolate_(dest,newstart,newdx,source,oldstart,olddx,padding);
  return dest;
}

void cubic_interpolate(BaseList<complex> dest, const BaseList<complex>& source)
{
  cubic_interpolate_(dest,source);
}

List<complex> cubic_interpolate(size_t newnp, const BaseList<complex>& source)
{
  List<complex> dest(newnp);
  cubic_interpolate_(dest,source);
  return dest;
}

} //namespace libcmatrix
